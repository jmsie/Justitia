import pandas as pd
import matplotlib.pyplot as plt
import matplotlib as mpl
from sklearn import linear_model


class Trade():
    def __init__(self):
        self.entryTime = 0
        self.entryTimeStamp = 0
        self.entryPrice = 0
        self.exitTimeStamp = 0
        self.exitPrice = 0
        self.position = 0

    def getProfit(self):
        if self.exitTime != 0:
            return self.position * (self.exitPrice - self.entryPrice)
        else:
            return 0


class MCReport_parser():
    def __init__(self, fileName):
        self.fileName = fileName
        self.listOfTrade = ''
        self.trades = []
        self.parse()

    def parse(self):
        self.listOfTrade = pd.read_excel(io=path, sheetname='List of Trades', skiprows=2)
        trades = []
        for index, row in self.listOfTrade.iterrows():
            tradeTime = pd.Timestamp.combine(row['Date'], row['Time'])
            tradeTimeStamp = tradeTime.timestamp()
            tradeType = row['Type']
            if 'Entry' in tradeType:
                # New trade
                trade = Trade()
                trades.append(trade)
                trade.entryTime = tradeTime
                trade.entryTimeStamp = tradeTimeStamp
                trade.entryPrice = row['Price']
                if 'Long' in tradeType:
                    trade.position = 1 * int(row['Contracts'])
                else:
                    trade.position = -1 * int(row['Contracts'])
            else:
                # Closing trade
                trade.exitTime = tradeTime
                trade.exitTimeStamp = tradeTimeStamp
                trade.exitPrice = row['Price']
        self.trades = trades


class Justitia():
    def __init__(self):
        self.allTrades = ""
        self.trainTrades = []
        self.testTrades = []

    # This function splits the report by time into train and test
    def splitTrades(self, timeStamp):
        for trade in self.allTrades:
            if trade.exitTimeStamp < timeStamp:
                self.trainTrades.append(trade)
            else:
                self.testTrades.append(trade)

    def getProfits(self, trades):
        profits = []
        for trade in trades:
            profits.append(trade.getProfit())
        return profits

    def getTimeStamps(self, trades):
        timeStamp = []
        for trade in trades:
            timeStamp.append(trade.exitTimeStamp)
        return timeStamp

    def cumsum(self, nums, offset=0):
        ret = [offset]
        for num in nums:
            ret.append(num + ret[-1])
        return ret[1:]

    def plotAllTrade(self):
        profits = self.cumsum(self.getProfits(self.allTrades))
        timeStamps = self.getTimeStamps(self.allTrades)

        plt.plot(timeStamps, profits)
        plt.show()

    def plotTrainTestTrades(self):
        if self.trainTrades == []:
            print("No training data found, use splitTrades() first")
            return

        trainProfits = self.cumsum(self.getProfits(self.trainTrades))
        trainTimeStamps = self.getTimeStamps(self.trainTrades)
        testProfits = self.cumsum(self.getProfits(self.testTrades), trainProfits[-1])
        testTimeStamps = self.getTimeStamps(self.testTrades)

        mpl.style.use("seaborn")
        fig, ax = plt.subplots(figsize=(10, 10))
        ax.set_title('Train/Test plot')

        plt.plot(trainTimeStamps, trainProfits)
        plt.plot(testTimeStamps, testProfits)

        plt.show()

    def linearAnalysis(self):
        if self.trainTrades == []:
            print("No training data found, use splitTrades() first")
            return
        from sklearn import linear_model
        from sklearn import datasets, linear_model
        from sklearn.metrics import mean_squared_error, r2_score

        trainProfits = self.cumsum(self.getProfits(self.trainTrades))
        trainTimeStamps = self.getTimeStamps(self.trainTrades)
        testProfits = self.cumsum(self.getProfits(self.testTrades), trainProfits[-1])
        testTimeStamps = self.getTimeStamps(self.testTrades)

        trainTimeStamps = pd.np.array(trainTimeStamps).reshape((-1, 1))
        testTimeStamps = pd.np.array(testTimeStamps).reshape((-1, 1))

        # Create linear regression object
        regr = linear_model.LinearRegression()

        # Train the train data
        regr.fit(trainTimeStamps, trainProfits)
        trainCoef = float(regr.coef_[0]) * 100000
        # Make predictions using the testing set
        trainPredict = regr.predict(trainTimeStamps)

        # Train the test data
        regr.fit(testTimeStamps, testProfits)
        testCoef = float(regr.coef_[0]) * 100000
        # Make predictions using the testing set
        testPredict = regr.predict(testTimeStamps)

        trainMSE = mean_squared_error(trainProfits, trainPredict)
        testMSE = mean_squared_error(testProfits, testPredict)
        trainR2 = r2_score(trainProfits, trainPredict)
        testR2 = r2_score(testProfits, testPredict)

        # Plot outputs
        mpl.style.use("seaborn")
        fig, ax = plt.subplots(figsize=(10, 10))
        ax.set_title('Train/Test linear analysis')

        plt.plot(trainTimeStamps, trainPredict)
        plt.plot(trainTimeStamps, trainProfits)

        plt.plot(testTimeStamps, testPredict)
        plt.plot(testTimeStamps, testProfits)

        mse = "Mean square error: train: {:.4f}  test: {:.4f} \n".format(trainMSE, testMSE)
        r2 = "Variance score: train: {:.6f}  test: {:.6f} \n".format(trainR2, testR2)
        coef = "Slope: train: {:.6f}  test: {:.6f} \n".format(trainCoef, testCoef)

        plt.text(trainTimeStamps[1], testProfits[0], mse + r2 + coef, fontsize=12)
        plt.show()


if __name__ == "__main__":
    path = r'C:\D\DORF\Justitia\reports\TXF1  MH_Bollinger Back-Testing Strategy Performance Report.xlsx'
    path = r'C:\D\DORF\Justitia\reports\TXF1  MH_VOLEX Back-Testing Strategy Performance Report.xlsx'
    splitTime = '2017-01-01'
    report = MCReport_parser(path)
    justitia = Justitia()
    justitia.allTrades = report.trades

    justitia.splitTrades(pd.to_datetime(splitTime).timestamp())
    # justitia.plotTrainTestTrades()
    justitia.linearAnalysis()


